/**********************************************************************
* HUFF implementation of ../solc/HorseStore.sol                       *
*                                                                     *
* This project is continued from the my experiment with the HUFF in   * 
* the evm-lab repository.                                             *
***********************************************************************/

#include "./Utils.huff"
#include "./DataStructures.huff"

/**********************************************************************
* Function Interfaces                                                 *
***********************************************************************/
// HorseStore functions
#define function HORSE_HAPPY_IF_FED_WITHIN() nonpayable returns (uint256)
#define function mintHorse() nonpayable returns ()
#define function horseIdToFedTimeStamp(uint256) nonpayable returns (uint256)
#define function feedHorse(uint256) nonpayable returns ()
#define function isHappyHorse(uint256) nonpayable returns (bool)

// ERC721
#define function balanceOf(address) view returns (uint256)
#define function ownerOf(uint256) view returns (address)
#define function name() nonpayable returns (string)
#define function symbol() nonpayable returns (string)
#define function totalSupply() nonpayable returns (uint256)
#define function transferFrom(address,address,uint256) nonpayable returns ()
#define function approve(address,uint256) nonpayable returns ()
#define function getApproved(uint256) nonpayable returns (address)
#define function setApprovalForAll(address,bool) nonpayable returns ()
#define function isApprovedForAll(address,address) nonpayable returns (bool)
// #define function safeTransferFrom(address,address, uint256, bytes) nonpayable returns ()
// #define function safeTransferFrom(address,address, uint256) nonpayable returns ()

// 0x23b872dd

// IERC721Enumerable
#define function tokenByIndex(uint256 index) view returns (uint256)
#define function tokenOfOwnerByIndex(address owner, uint256 index) view returns (uint256)

// @TODO: ERC165
// @TODO: Add metadata

/**********************************************************************
* Events                                                              *
***********************************************************************/
#define event Transfer(address,address,uint256)
#define event Approval(address,address,uint256)
#define event ApprovalForAll(address,address,bool)

/**********************************************************************
* Errors                                                              *
***********************************************************************/
#define error HorseStoreForbiddenError()
#define error ERC721InvalidOperator(address)
#define error ERC721NonexistentToken(uint256)
#define error ERC721InvalidReceiver(address)
#define error ERC721NonexistentToken(uint256)
#define error ERC721InsufficientApproval(address,uint256)
#define error ERC721OutOfBoundsIndex(address, uint256)

/**********************************************************************
* Constants                                                           *
***********************************************************************/
#define constant HORSE_HAPPY_IF_FED_WITHIN_SECONDS = 0x15180 // 1 day
#define constant NAME_OFFSET                       = 0x0000000000000000000000000000000000000000000000000000000000000080
#define constant NAME_LENGTH_OFFSET                = 0x00000000000000000000000000000000000000000000000000000000000000a0
#define constant SYMBOL_OFFSET                     = 0x0000000000000000000000000000000000000000000000000000000000000020
#define constant SYMBOL_LENGTH_OFFSET              = 0x0000000000000000000000000000000000000000000000000000000000000040

/**********************************************************************
* Storage                                                             *
***********************************************************************/
#define constant OWNER_LOCATION                = FREE_STORAGE_POINTER()
#define constant BALANCE_LOCATION              = FREE_STORAGE_POINTER()
#define constant APPROVALS_LOCATION            = FREE_STORAGE_POINTER()
#define constant OPERATOR_APPROVALS_LOCATION   = FREE_STORAGE_POINTER()
#define constant ALL_TOKENS_LOCATION           = FREE_STORAGE_POINTER()
#define constant ALL_TOKENS_INDEX_LOCATION     = FREE_STORAGE_POINTER()
#define constant OWNED_TOKENS_LOCATION         = FREE_STORAGE_POINTER()
#define constant OWNED_TOKENS_INDEX_LOCATION   = FREE_STORAGE_POINTER()
#define constant HORSE_FED_TIMESTAMPS_LOCATION = FREE_STORAGE_POINTER()

/**********************************************************************
* Entrypoint                                                          *
***********************************************************************/
#define macro MAIN() = takes(0) returns (0) {
  0x00 calldataload push1 0xe0 shr           // [function_selector]

  dup1 __FUNC_SIG(mintHorse)                 // [__FUNC_SIG(mintHorse), function_selector, function_selector]
  eq mint_horse_dest jumpi                   // [function_selector]

  dup1 __FUNC_SIG(feedHorse)                 // [__FUNC_SIG(feedHorse), function_selector, function_selector]
  eq feed_horse_dest jumpi                   // [function_selector]

  dup1 __FUNC_SIG(approve)                   // [__FUNC_SIG(approve), function_selector, function_selector]
  eq approve_dest jumpi                      // [function_selector]

  dup1 __FUNC_SIG(setApprovalForAll)         // [__FUNC_SIG(transferFrom), function_selector, function_selector]
  eq set_approval_for_all_dest jumpi         // [function_selector]

  dup1 __FUNC_SIG(transferFrom)              // [__FUNC_SIG(transferFrom), function_selector, function_selector]
  eq transfer_from_dest jumpi                // [function_selector]

  // View functions >>>

  dup1 __FUNC_SIG(horseIdToFedTimeStamp)     // [__FUNC_SIG(horseIdToFedTimeStamp), function_selector, function_selector]
  eq horse_id_to_fed_timestamp_dest jumpi    // [function_selector]

  dup1 __FUNC_SIG(name)                      // [__FUNC_SIG(name), function_selector, function_selector]
  eq name_dest jumpi                         // [function_selector]

  dup1 __FUNC_SIG(symbol)                    // [__FUNC_SIG(symbol), function_selector, function_selector]
  eq symbol_dest jumpi                       // [function_selector]

  dup1 __FUNC_SIG(totalSupply)               // [__FUNC_SIG(totalSupply), function_selector, function_selector]
  eq total_supply_dest jumpi                 // [function_selector]

  dup1 __FUNC_SIG(ownerOf)                   // [__FUNC_SIG(ownerOf), function_selector, function_selector]
  eq owner_of_dest jumpi                     // [function_selector]

  dup1 __FUNC_SIG(balanceOf)                 // [__FUNC_SIG(balanceOf), function_selector, function_selector]
  eq balance_of_dest jumpi                   // [function_selector]

  dup1 __FUNC_SIG(HORSE_HAPPY_IF_FED_WITHIN) // [__FUNC_SIG(HORSE_HAPPY_IF_FED_WITHIN), function_selector, function_selector]
  eq horse_happy_if_fed_within_dest jumpi    // [function_selector]

  dup1 __FUNC_SIG(isHappyHorse)              // [__FUNC_SIG(isHappyHorse), function_selector, function_selector]
  eq is_happy_horse_dest jumpi               // [function_selector]

  dup1 __FUNC_SIG(getApproved)               // [__FUNC_SIG(getApproved), function_selector, function_selector]
  eq get_approved_dest jumpi                 // [function_selector]

  dup1 __FUNC_SIG(isApprovedForAll)          // [__FUNC_SIG(isApprovedForAll), function_selector, function_selector]
  eq is_approved_for_all_dest jumpi          // [function_selector]

  dup1 __FUNC_SIG(tokenOfOwnerByIndex)       // [__FUNC_SIG(tokenOfOwnerByIndex), function_selector, function_selector]
  eq token_of_owner_by_index_dest jumpi      // [function_selector]

  dup1 __FUNC_SIG(tokenByIndex)              // [__FUNC_SIG(tokenByIndex), function_selector, function_selector]
  eq token_by_index_dest jumpi // [function_selector]

  0x00 0x00 revert                           // [0x00, 0x00] -> []

  // Function destinations
  mint_horse_dest:
    pop MINT_HORSE()
  feed_horse_dest:
    pop FEED_HORSE()
  approve_dest:
    pop ERC721_APPROVE()
  set_approval_for_all_dest:
    pop ERC721_SET_APPROVAL_FOR_ALL()
  horse_id_to_fed_timestamp_dest:
    pop HORSE_ID_TO_FED_TIMESTAMP()
  symbol_dest:
    pop ERC721_SYMBOL()
  name_dest:
    pop ERC721_NAME()
  total_supply_dest:
    pop ERC721_TOTAL_SUPPLY()
  owner_of_dest:
    pop ERC721_OWNER_OF()
  balance_of_dest:
    pop ERC721_BALANCE_OF()
  horse_happy_if_fed_within_dest:
    pop READ_HORSE_HAPPY_IF_FED_WITHIN()
  is_happy_horse_dest:
    pop IS_HAPPY_HORSE()
  get_approved_dest:
    pop ERC721_GET_APPROVED()
  is_approved_for_all_dest:
    pop ERC721_IS_APPROVED_FOR_ALL()
  transfer_from_dest:
    pop ERC721_TRANSFER_FROM()
  token_of_owner_by_index_dest:
    pop ERC721_ENUMERABLE_TOKEN_OF_OWNER_BY_INDEX()
  token_by_index_dest:
    pop ERC721_ENUMERABLE_TOKEN_BY_INDEX()
}

/**********************************************************************
* Constructor                                                         *
***********************************************************************/
#define macro CONSTRUCTOR() = takes(0) returns(0) {
  _ERC721_CONSTRUCTOR()
}

/**********************************************************************
* Core functions                                                      *
***********************************************************************/

/// @notice Feed Horse
#define macro FEED_HORSE() = takes(0) returns (0) {
  _NON_PAYABLE()

  [OWNER_LOCATION]                         // [OWNER_LOCATION, token_id]
  0x04 calldataload                        // [token_id, OWNER_LOCATION]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)        // [token_owner_slot]
  sload                                    // [owner]
  caller                                   // [caller, owner]
  eq iszero                                // [caller != owner]
  forbidden_jump_dest jumpi                // []

  timestamp                                // [timestamp]
  [HORSE_FED_TIMESTAMPS_LOCATION]          // [HORSE_FED_TIMESTAMPS_LOCATION, timestamp]
  0x04 calldataload                        // [token_id, HORSE_FED_TIMESTAMPS_LOCATION, timestamp]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)        // [timestamp_slot, timstamp]
  sstore                                   // []
  0x00 0x00 return

  forbidden_jump_dest:
    __ERROR(HorseStoreForbiddenError)      // [error_selector]
    0x00 mstore                            // []
    0x04 0x00 revert
}

/// @notice Mint Horse
#define macro MINT_HORSE() = takes(0) returns (0) {
  _NON_PAYABLE()

  _ERC721_TOTAL_SUPPLY()                  // [token_id]
  dup1                                    // [token_id, token_id]
  caller                                  // [caller, token_id, token_id]
  swap1                                   // [token_id, caller, token_id]

  [OWNER_LOCATION] swap1                  // [token_id, OWNER_LOCATION, caller, token_id]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)       // [token_owner_slot, caller, token_id]
  sstore                                  // [token_id]

  [BALANCE_LOCATION]                       // [BALANCE_LOCATION, token_id]
  caller                                   // [msg.sender, BALANCE_LOCATION, token_id]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)        // [balance_slot, token_id]
  dup1                                     // [balance_slot, balance_slot, token_id]
  sload                                    // [prev_balance, balance_slot, token_id]
  0x01 add                                 // [prev_balance + 1, balance_slot, token_id]
  swap1                                    // [balance_slot, balances[msg.sender] + 1, token_id]
  sstore                                   // [token_id]
  dup1                                     // [token_id, token_id]

  _ERC721_ENUMERABLE_ADD_TO_ALL_TOKENS_ENURATIONS() // [token_id]
  dup1                                              // [token_id, token_id]
  caller                                            // [msg.sender, token_id, token_id]
  _ERC721_ENUMERABLE_ADD_TO_OWNER_ENUMERATIONS()    // [token_id]

  caller 0x00                                       // [from (0x00), to (msg.sender), token_id]
  __EVENT_HASH(Transfer)                            // [event_hash, from (0x00), to (msg.sender), token_id]
  0x00 0x00 log4
  0x00 0x00 return
}

/**********************************************************************
* View functions                                                      *
***********************************************************************/

/// @notice Is Happy Horse
#define macro IS_HAPPY_HORSE() = takes(0) returns (0) {
  [HORSE_FED_TIMESTAMPS_LOCATION]          // [HORSE_FED_TIMESTAMPS_LOCATION]
  0x04 calldataload                        // [token_id, HORSE_FED_TIMESTAMPS_LOCATION]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)        // [timestamp_slot]
  sload                                    // [fed_timestamp]
  timestamp                                // [timestamp, fed_timestamp]
  dup2 dup2                                // [timestamp, fed_timestamp, timestamp, fed_timestamp]
  sub                                      // [timestamp - fed_timestamp, timestamp, fed_timestamp]
  [HORSE_HAPPY_IF_FED_WITHIN_SECONDS]      // [HORSE_HAPPY_IF_FED_WITHIN_SECONDS, timestamp - fed_timestamp, timestamp, fed_timestamp]
  gt                                       // [timestamp - fed_timestamp > HORSE_HAPPY_IF_FED_WITHIN_SECONDS, timestamp, fed_timestamp]
  start_return_true jumpi                  // [timestamp, fed_timestamp]
  eq                                       // [timestamp == fed_timestamp]
  start_return jump                        // []

  start_return_true:
  0x01

  start_return:
  0x00 mstore
  0x20 0x00 return
}

/// @notice Horse Happy If Fed Within
#define macro READ_HORSE_HAPPY_IF_FED_WITHIN() = takes(0) returns (0) {
  [HORSE_HAPPY_IF_FED_WITHIN_SECONDS]      // [HORSE_HAPPY_IF_FED_WITHIN_SECONDS]
  0x00 mstore                              // []
  0x20 0x00 return                         // []
}

/// @notice Horse Id To Fed Timestamp
#define macro HORSE_ID_TO_FED_TIMESTAMP() = takes(0) returns (0) {
  [HORSE_FED_TIMESTAMPS_LOCATION]         // [HORSE_FED_TIMESTAMPS_LOCATION]
  0x04 calldataload                       // [token_id, HORSE_FED_TIMESTAMPS_LOCATION]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)       // [timestamp_slot]
  sload                                   // [timestamp]
  0x00 mstore                             // []
  0x20 0x00 return
}

/**********************************************************************
* ERC721 External                                                     *
***********************************************************************/

/// @notice Name
/// @notice Returns the token name string
#define macro ERC721_NAME() = takes (0) returns (0) {
  _GET_IMMUTABLE(NAME_OFFSET, 0x00)           // [name_value]
  _GET_IMMUTABLE(NAME_LENGTH_OFFSET, 0x00)    // [name_length, name_value]
  0x20 0x00 mstore                            // [name_length, name_value]
  0x20 mstore                                 // [name_value]
  0x40 mstore                                 // []
  0x60 0x00 return                            // []
}

/// @notice Symbol
/// @notice Returns the token symbol string
#define macro ERC721_SYMBOL() = takes (0) returns (0) {
  _GET_IMMUTABLE(SYMBOL_OFFSET, 0x00)         // [symbol_value]
  _GET_IMMUTABLE(SYMBOL_LENGTH_OFFSET, 0x00)  // [symbol_length, symbol_value]
  0x20 0x00 mstore                            // [symbol_length, symbol_value]
  0x20 mstore                                 // [symbol_value]
  0x40 mstore                                 // []
  0x60 0x00 return                            // []
}

/// @notice Balance Of
/// @notice Returns the number of tokens owned by the given address
#define macro ERC721_BALANCE_OF() = takes (0) returns (0) {
  0x04 calldataload                          // [address]
  _ERC721_BALANCE_OF()                       // [balance]
  0x00 mstore                                // []
  0x20 0x00 return                           // []
}

/// @notice Total Supply
/// @notice Returns the total number of tokens in existence
#define macro ERC721_TOTAL_SUPPLY() = takes (0) returns (0) {
  [ALL_TOKENS_LOCATION]                      // [ALL_TOKENS_LOCATION]
  sload                                      // [total_supply]
  0x00 mstore                                // []
  0x20 0x00 return                           // []
}

/// @notice Owner Of
/// @notice Returns the owner of the token
#define macro ERC721_OWNER_OF() = takes (0) returns(0) {
  0x04 calldataload                     // [token_id]
  _ERC721_OWNER_OF()                    // [owner]
  0x00 mstore                           // []
  0x20 0x00 return
}

/// @notice Approve
#define macro ERC721_APPROVE() = takes (0) returns(0) {
  _NON_PAYABLE()
  0x04 calldataload                       // [spender, spender]

  0x24 calldataload                       // [token_id, spender]
  dup1                                    // [token_id, token_id, spender]
  _ONLY_OWNER()                           // [token_id, spender]
  dup2 dup2                               // [token_id, spender, token_id, spender]
  [APPROVALS_LOCATION]                    // [APPROVALS_LOCATION, token_id, spender, token_id, spender]
  swap1                                   // [token_id, APPROVALS_LOCATION, spender, token_id spender]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)       // [approval_slot, spender, token_id, spender]
  sstore                                  // [token_id, spender]
  swap1                                   // [spender, token_id]

  caller                                  // [msg.sender, spender, token_id]
  __EVENT_HASH(Approval)                  // [event_hash, msg.sender, spender, token_id]
  0x00 0x00 log4
  0x00 0x00 return
}

#define macro ERC721_GET_APPROVED() = takes(0) returns(0) {
  0x04 calldataload                       // [token_id, APPROVALS_LOCATION]
  _ERC721_GET_APPROVED()
  0x00 mstore                             // []
  0x20 0x00 return                        // []
}

#define macro ERC721_SET_APPROVAL_FOR_ALL() = takes(0) returns(0) {
  _NON_PAYABLE()
  0x04 calldataload                      // [approved]
  0x24 calldataload                      // [operator, approved]
  swap1                                  // [approved, operator]

  _VALIDATE_OPERATOR()                   // [operator, approved]

  caller                                 // [msg.sender, operator, approved]
  dup3 dup3 dup3                         // [msg.sender, operator, approved, msg.sender, operator, approved] 
  [OPERATOR_APPROVALS_LOCATION]          // [OPERATOR_APPROVALS_LOCATION, msg.sender, operator, approved, msg.sender, operator, approved]
  _HASHMAP_2D_GET_SLOT_FROM_KEYS(0x00)   // [approval_slot, approved, msg.sender, operator, approved]
  sstore                                 // [msg.sender, operator, approved]

  // Emit event
  swap2                                  // [approved, operator, msg.sender]
  0x00 mstore                            // [operator, msg.sender]
  swap1                                  // [msg.sender, operator]
  __EVENT_HASH(ApprovalForAll)           // [event_hash, msg.sender, operator]
  0x20 0x00 log3                         // []
  0x00 0x00 return
}

#define macro ERC721_IS_APPROVED_FOR_ALL() = takes(0) returns(0) {
  0x24 calldataload                       // [operator]
  0x04 calldataload                       // [owner, operator]
  _ERC721_IS_APPROVED_FOR_ALL()           // [approved]
  0x00 mstore
  0x20 0x00 return
}

// calldata: [from, to, token_id]
#define macro ERC721_TRANSFER_FROM() = takes(0) returns(0) {
  // from, to, token_id
  0x44 calldataload                      // [token_id]
  0x24 calldataload                      // [to, token_id]
  0x04 calldataload                      // [from, to, token_id]
  _ERC721_TRANSFER_FROM()
}

/**********************************************************************
* ERC721 Enumerable External                                          *
***********************************************************************/

#define macro ERC721_ENUMERABLE_TOKEN_OF_OWNER_BY_INDEX() = takes(0) returns(0) {
  0x04 calldataload                        // [owner]
  0x24 calldataload                        // [index, owner]
  swap1                                    // [owner, index]
  dup2 dup2                                // [owner, index, owner, index]

  _ERC721_BALANCE_OF()                     // [balance, index, owner, index]

  gt                                       // [balance > index, owner, index]
  iszero                                   // [balance <= index, owner, index]
  out_of_bounds_jump_dest jumpi            // [owner, index]

  [OWNED_TOKENS_LOCATION]                  // [OWNED_TOKENS_LOCATION, owner, index]
  _HASHMAP_2D_GET_SLOT_FROM_KEYS(0x00)     // [slot]
  sload                                    // [token_id]
  0x00 mstore
  0x20 0x00 return

  out_of_bounds_jump_dest:
    __ERROR(ERC721OutOfBoundsIndex)         // [error_selector, owner, index]
    0x00 mstore                             // [owner, index]
    0x04 mstore                             // [index]
    0x24 mstore                             // []
    0x44 0x00 revert
}

#define macro ERC721_ENUMERABLE_TOKEN_BY_INDEX() = takes(0) returns(0) {
  0x04 calldataload                        // [index]
  dup1                                     // [index, index]
  _ERC721_TOTAL_SUPPLY()                   // [total_supply, index, index]

  gt iszero                                // [total_supply <= index, index]
  out_of_bounds_jump_dest jumpi            // [index]

  [ALL_TOKENS_LOCATION]                    // [ALL_TOKENS_LOCATION, index]
  _HASHMAP_ARRAY_GET_SLOT_FROM_KEYS(0x00)  // [slot]
  sload                                    // [token_id]
  0x00 mstore
  0x20 0x00 return

  out_of_bounds_jump_dest:
    0x00 __ERROR(ERC721OutOfBoundsIndex)    // [error_selector, owner(0x00), index]
    0x00 mstore                             // [owner, index]
    0x04 mstore                             // [index]
    0x24 mstore                             // []
    0x44 0x00 revert
}


/**********************************************************************
* ERC721 Enumerable Internal                                          *
***********************************************************************/

#define macro _ERC721_ENUMERABLE_ADD_TO_OWNER_ENUMERATIONS() = takes(2) returns(0) {
  // input stack: [owner, token_id]
  dup2                                       // [token_id, owner, token_id]
  swap1                                      // [owner, token_id, token_id]
  dup1                                       // [owner, owner, owner, token_id, token_id]

  _ERC721_BALANCE_OF()                       // [balance, owner, token_id, token_id]
  0x01 swap1 sub                             // [index, owner, token_id, token_id]
  dup1                                       // [index, index, owner, token_id, token_id]
  swap2                                      // [owner, index, index, token_id, token_id]

  [OWNED_TOKENS_LOCATION]                    // [OWNED_TOKENS_LOCATION, owner, index, index, token_id, token_id]
  _HASHMAP_2D_GET_SLOT_FROM_KEYS(0x00)       // [owned_tokens_slot, index, token_id, token_id]
  swap1 swap2 swap1                          // [owned_tokens_slot, token_id, index, token_id]
  sstore                                     // [index, token_id]

  swap1                                      // [token_id, index]
  [OWNED_TOKENS_INDEX_LOCATION]              // [OWNED_TOKENS_INDEX_LOCATION, token_id, index]
  swap1                                      // [token_id, OWNED_TOKENS_INDEX_LOCATION, index]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)          // [slot, index]
  sstore                                     // [index]
}

#define macro _ERC721_ENUMERABLE_ADD_TO_ALL_TOKENS_ENURATIONS() = takes(1) returns(0) {
  // input stack: [token_id]
  dup1
  [ALL_TOKENS_LOCATION]                     // [index, token_id, token_id]
  [ALL_TOKENS_INDEX_LOCATION]               // [ALL_TOKENS_INDEX_LOCATION, index, token_id, token_id]
  swap1                                     // [index, ALL_TOKENS_INDEX_LOCATION, token_id, token_id]
  swap2                                     // [token_id, ALL_TOKENS_INDEX_LOCATION, index, token_id]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)         // [_allTokensIndex_slot, index, token_id]
  sstore                                    // [token_id]

  [ALL_TOKENS_LOCATION]                     // [ALL_TOKENS_LOCATION, token_id] 
  dup1                                      // [ALL_TOKENS_LOCATION, ALL_TOKENS_LOCATION, token_id]
  sload                                     // [length, ALL_TOKENS_LOCATION, token_id]
  swap1                                     // [ALL_TOKENS_LOCATION, length, token_id]
  _HASHMAP_ARRAY_GET_SLOT_FROM_KEYS(0x00)   // [slot, token_id]
  sstore                                    // []

  [ALL_TOKENS_LOCATION]                     // [ALL_TOKENS_LOCATION]
  dup1                                      // [ALL_TOKENS_LOCATION, ALL_TOKENS_LOCATION]
  sload                                     // [length, ALL_TOKENS_LOCATION]
  0x01 add                                  // [length + 1, ALL_TOKENS_LOCATION]
  swap1                                     // [ALL_TOKENS_LOCATION, length + 1]
  sstore                                    // []
}

#define macro _ERC721_ENUMERABLE_REMOVE_TOKEN_FROM_OWNER_ENUMERATION() = takes(2) returns(0) {
  // input stack: [from, token_id]
  dup2 dup2                                 // [from, token_id, from, token_id]
  _ERC721_BALANCE_OF()                      // [last_token_index, token_id, from, token_id]
  swap1                                     // [token_id, last_token_index, from, token_id]
  
  [OWNED_TOKENS_INDEX_LOCATION] swap1       // [token_id, OWNED_TOKENS_INDEX_LOCATION, last_token_index, from, token_id]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00) sload   // [token_index, last_token_index, from, token_id]
  dup2 dup2                                 // [token_index, last_token_index, token_index, last_token_index, from, token_id]
  eq                                        // [token_index == last_token_index, token_index, last_token_index, from, token_id]
  remove_and_pop_dest jumpi                 // [token_index, last_token_index, from, token_id]

  swap2                                     // [from, last_token_index, token_index, token_id]
  dup2 dup2                                 // [from, last_token_index, from, last_token_index, token_index, token_id]
  [OWNED_TOKENS_LOCATION]                   // [OWNED_TOKENS_LOCATION, from, last_token_index, from, last_token_index, token_index, token_id]
  _HASHMAP_2D_GET_SLOT_FROM_KEYS(0x00)      // [owned_tokens_slot, from, last_token_index, token_index, token_id]
  sload                                     // [last_token_id, from, last_token_index, token_index, token_id]

  swap3                                     // [token_index, from, last_token_index, last_token_id, token_id]
  swap1                                     // [from, token_index, last_token_index, last_token_id, token_id]
  dup2 dup2                                 // [from, token_index, from, token_index, last_token_index, last_token_id, token_id]
  
  [OWNED_TOKENS_LOCATION]                   // [OWNED_TOKENS_LOCATION, from, token_index, from, token_index, last_token_index, last_token_id, token_id]
  _HASHMAP_2D_GET_SLOT_FROM_KEYS(0x00)      // [slot, from, token_index, last_token_index, last_token_id, token_id]

  swap1                                     // [from, slot, token_index, last_token_index, last_token_id, token_id]
  swap4                                     // [last_token_id, slot, token_index, last_token_index, from, token_id]
  dup1                                      // [last_token_id, last_token_id, slot, token_index, last_token_index, from, token_id]
  swap2                                     // [slot, last_token_id, last_token_id, token_index, last_token_index, from, token_id]
  sstore                                    // [last_token_id, token_index, last_token_index, from, token_id]  

  [OWNED_TOKENS_INDEX_LOCATION]             // [OWNED_TOKENS_INDEX_LOCATION, last_token_id, token_index, last_token_index, from, token_id]
  swap1 _HASHMAP_GET_SLOT_FROM_KEYS(0x00)   // [slot, token_index, last_token_index, from, token_id]
  sstore                                    // [last_token_index, from, token_id]
  remove_dest jump

  remove_and_pop_dest:
    pop

  remove_dest:                              // [last_token_index, from, token_id]
  swap1                                     // [from, last_token_index, token_id]
  [OWNED_TOKENS_LOCATION]                   // [OWNED_TOKENS_LOCATION, from, last_token_index, token_id]
  _HASHMAP_2D_GET_SLOT_FROM_KEYS(0x00)      // [slot, token_id]
  0x00 swap1 sstore                         // [token_id]

  [OWNED_TOKENS_INDEX_LOCATION]             // [OWNED_TOKENS_INDEX_LOCATION, token_id]
  swap1 _HASHMAP_GET_SLOT_FROM_KEYS(0x00)   // [slot]
  0x00 swap1 sstore                         // []
}

/**********************************************************************
* ERC721 Internal                                          *
***********************************************************************/

#define macro _ERC721_CONSTRUCTOR() = takes(0) returns(0) {
  // Constructor arguments:
  // ?, name_size, name, ?, symbol_size, symbol
  // Example: 
    // bytes.concat(abi.encode("Token"), abi.encode("TKN"))
    // abi.encode("Token") = 0x00000000000000000000000000000000000000000000000000000000000000200000000000000000000000000000000000000000000000000000000000000005546f6b656e000000000000000000000000000000000000000000000000000000
  0xb                                     // [offset]
  dup1                                    // [offset, offset]
  codesize                                // [total_size, offset, offset]
  sub                                     // [runtime_size, offset]
  dup1                                    // [runtime_size, runtime_size, offset]
  swap2                                   // [offset, runtime_size, runtime_size]
  returndatasize                          // [return_offset, offset, runtime_size, runtime_size]
  codecopy                                // [runtime_size]

  // Return the runtime bytecode.
  returndatasize                          // [return_offset, runtime_size]
  return                                  // []
}

/// @notice Balance Of
/// @notice Returns the number of tokens owned by the given address
#define macro _ERC721_BALANCE_OF() = takes (1) returns (1) {
  // input stack: [address]
  [BALANCE_LOCATION]                         // [BALANCE_LOCATION, address]
  swap1                                      // [address, BALANCE_LOCATION]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)          // [balance_slot]
  sload                                      // [balance]
}

#define macro _ERC721_GET_APPROVED() = takes(1) returns(0) {
  // input stack: [token_id]
  [APPROVALS_LOCATION]                            // [APPROVALS_LOCATION, token_id]
  swap1                                           // [token_id, APPROVALS_LOCATION]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)               // [slot]
  sload                                           // [approved_spender]
}

#define macro _ERC721_TOTAL_SUPPLY() = takes(0) returns(1) {
  [ALL_TOKENS_LOCATION]                      // [ALL_TOKENS_LOCATION]
  sload                                      // [total_supply]
}

/// @notice Owner Of
/// @notice Returns the owner of the token
#define macro _ERC721_OWNER_OF() = takes (1) returns(1) {
  // input stack: [token_id]
  [OWNER_LOCATION]                      // [OWNER_LOCATION, token_id]
  swap1                                 // [token_id, OWNER_LOCATION]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)     // [token_owner_slot]
  sload                                 // [owner]
}

#define macro _ERC721_IS_APPROVED_FOR_ALL() = takes(2) returns(1) {
  // input stack: [owner, operator]
  [OPERATOR_APPROVALS_LOCATION]                   // [OPERATOR_APPROVALS_LOCATION, owner, operator]
  _HASHMAP_2D_GET_SLOT_FROM_KEYS(0x00)            // [approval_slot]
  sload                                           // [approved]
}

// @TODO: Implement safeTransferFrom
#define macro _ERC721_TRANSFER_FROM() = takes(3) returns(0) {
  // input stack: [from, to, token_id]
  swap1                                  // [to, from, token_id]
  _NON_ZERO_RECEIVER(0x00)               // [to, from, token_id]
  swap2                                  // [token_id, from, to]
  dup1                                   // [token_id, token_id, from, to]
  _ERC721_OWNER_OF()                     // [owner, token_id, from, to]

  dup1                                   // [owner, owner, token_id, from, to]
  caller                                 // [msg.sender, owner, owner, token_id, from, to]
  eq                                     // [msg.sender == owner, owner, token_id, from, to]
  transfer_dest_with_pop jumpi           // [owner, token_id, from, to]

  caller                                  // [msg.sender, owner, token_id, from, to]
  swap1                                   // [owner, msg.sender, token_id, from, to]
  _ERC721_IS_APPROVED_FOR_ALL()           // [approved, token_id, from, to]
  transfer_dest jumpi                     // [token_id, from, to]

  dup1                                    // [token_id, token_id, from, to]
  _ERC721_GET_APPROVED()                  // [approved_spender, token_id, from, to]
  caller                                  // [msg.sender, approved_spender, token_id, from, to]
  eq                                      // [msg.sender == approved_spender, token_id, from, to]
  transfer_dest jumpi                      // [token_id, from, to]

  __ERROR(ERC721InsufficientApproval)     // [error_selector, token_id, from, to]
  0x00 mstore                             // [token_id, from, to]
  caller 0x04 mstore                      // [token_id, from, to]
  0x24 mstore                             // [from, to]
  0x24 0x00 revert

  transfer_dest_with_pop:                 // [trash, token_id, from, to]
  pop

  transfer_dest:                          // [token_id, from, to]
  dup3 dup3 dup3                          // [token_id, from, to, token_id, from, to]

  [OWNER_LOCATION]                        // [OWNER_LOCATION, token_id, from, to, token_id, from, to]
  swap1                                   // [token_id, OWNER_LOCATION, from, to, token_id, from, to]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)       // [token_owner_slot, from, to, token_id, from, to]
  swap1                                   // [from, token_owner_slot, to, token_id, from, to]
  swap2                                   // [to, token_owner_slot, from, token_id, from, to]
  swap1                                   // [token_owner_slot, to, from, token_id, from, to]
  sstore                                  // [from, token_id, from, to]

  [BALANCE_LOCATION]                      // [BALANCE_LOCATION, from, token_id, from, to]
  swap1                                   // [from, BALANCE_LOCATION, token_id, from, to]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)       // [balance_slot, token_id, from, to]
  dup1                                    // [balance_slot, balance_slot, token_id, from, to]
  sload                                   // [prev_from_balance, balance_slot, token_id, from, to]
  0x01 swap1 sub                          // [prev_from_balance - 1, balance_slot, token_id, from, to]
  swap1                                   // [balance_slot, prev_from_balance - 1, token_id, from, to]
  sstore                                  // [token_id, from, to]

  swap2                                   // [to, from, token_id]
  dup1                                    // [to, to, from, token_id]
  [BALANCE_LOCATION]                      // [BALANCE_LOCATION, to, to, from, token_id]
  swap1                                   // [to, BALANCE_LOCATION, to, from, token_id]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)       // [balance_slot, to, from, token_id]
  dup1                                    // [balance_slot, balance_slot, to, from, token_id]
  sload                                   // [prev_balance, balance_slot, to, from, token_id]
  0x01 add                                // [prev_balance + 1, balance_slot, to, from, token_id]
  swap1                                   // [balance_slot, prev_balance + 1, to, from, token_id]
  sstore                                  // [to, from, token_id]

  swap2                                   // [token_id, from, to]
  swap1                                   // [from, token_id, to]
  dup2 dup2                               // [from, token_id, from, token_id, to]

  /*
   * ERC721Enumerable
  */
  _ERC721_ENUMERABLE_REMOVE_TOKEN_FROM_OWNER_ENUMERATION() // [from, token_id, to]
  swap2                                                    // [to, token_id, from]
  dup2 dup2                                                // [to, token_id, to, token_id, from]
  _ERC721_ENUMERABLE_ADD_TO_OWNER_ENUMERATIONS()           // [to, token_id, from]

  swap1                                   // [token_id, to, from]
  swap2                                   // [from, to, token_id]
  __EVENT_HASH(Transfer)                  // [event_hash, from, to, token_id]
  0x00 0x00 log4

  0x00 0x00 return
}

/**********************************************************************
* Validation                                                          *
***********************************************************************/

#define macro _NON_ZERO_RECEIVER(memory_ptr) = takes(1) returns(1) {
  // input stack: [receiver]
  dup1 0x00 eq                                // [receiver == 0x00, receiver]
  iszero                                      // [receiver != 0x00, receiver]
  continue_jump_dest jumpi                    // [receiver]
  __ERROR(ERC721InvalidReceiver)              // [error_selector, receiver]
  <memory_ptr> mstore                         // [receiver]
  <memory_ptr> 0x04 add mstore                // []
  0x24 <memory_ptr> revert                    // []
  continue_jump_dest:                         // [receiver]
}

#define macro _VALIDATE_OPERATOR() = takes(1) returns(1) {
  // input stack: [operator]
  dup1
  0x00 eq                                    // [operator == 0x00, operator]
  iszero                                     // [operator != 0x00, operator]
  continue_jump_dest jumpi                   // [operator]

  __ERROR(ERC721InvalidOperator)              // [error_selector, operator]
  0x00 mstore                                 // [operator]
  0x04 mstore                                 // []
  0x24 0x00 revert                            // []

  continue_jump_dest:                         // [operator]
}

#define macro _ONLY_OWNER() = takes(1) returns(0) {
  // input stack: [token_id]
  [OWNER_LOCATION]                           // [OWNER_LOCATION, token_id]
  swap1                                      // [token_id, OWNER_LOCATION]
  _HASHMAP_GET_SLOT_FROM_KEYS(0x00)          // [owner_slot]
  sload                                      // [owner]  

  caller                                     // [caller, owner]
  eq                                         // [caller == owner]
  continue_jump_dest jumpi                   // []

  __ERROR(ForbiddenError)                    // [error_selector]
  0x00 mstore                                // []
  0x04 0x00 revert

  continue_jump_dest:
}

// 0x23b872dd000000000000000000000000be862ad9abfe6f22bcb087716c7d89a26051f74c0000000000000000000000006a1ce1eb90eddffd611e8f1530305304930780b50000000000000000000000000000000000000000000000000000000000000000
